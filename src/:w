use std::panic;

use crate::datatypes::{program_data::{self, ProgramData}, stack_frame, token::{BuiltInFunctions, Identifiers, MemoryLocations, Token, TokenType}};

#[derive(Debug, PartialEq, Clone)]
pub struct Statement {
    pub col: usize,
    pub line: usize,
    pub start_pos: usize,
    pub end_pos: usize,
    pub statement_type: Statements
}

#[derive(Debug, PartialEq, Clone)]
pub struct Function {
    pub return_type: VariableType,
    pub args: Vec<FunctionArg>,
    pub first_stack_frame: usize
}

impl Statement {
    #[inline]
    pub fn new(token: &Token, end_pos: usize, statement_type: Statements) -> Self {
        Self {
            col: token.col,
            line: token.line,
            start_pos: token.start_pos,
            end_pos,
            statement_type,
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct FunctionArg {
    pub arg_var_type : VariableType,
    pub arg_name : String,
    pub memory_location : MemoryLocationsAst
}

#[derive(Debug, PartialEq, Clone)]
pub struct FunctionDeclaration {
    pub args : Vec<FunctionArg>,
    pub name : String,
    pub return_type : VariableType,
}

#[derive(Debug, PartialEq, Clone)]
pub enum Statements {
    Terminate,
    EOF,
    VariableDeclaration(VariableDeclaration),
    FunctionDeclaration(FunctionDeclaration),
    StackFramePop,
    Expression(Expression),
}

#[derive(Debug, PartialEq, Clone)]
pub enum BuiltInFunctionsAst {
    Assembly(Box<Expression>),
    Format(Format),
    StackOffset(String),
    BranchLinked(BranchLinkedAst)
}

#[derive(Debug, PartialEq, Clone)]
pub enum MemoryLocationsAst {
    Stack,
    Register(String)
}

#[derive(Debug, PartialEq, Clone)]
pub struct BranchLinkedAst {
    pub args : Vec<Expression>,
    pub function_name : String
}

impl BuiltInFunctionsAst {
    pub fn parse(&self, program_data : &mut ProgramData, stack_frame : usize) -> Option<Literal> {
        return match self {
            BuiltInFunctionsAst::StackOffset(identifier) => {
                let var = program_data.get_stack_variable(stack_frame, identifier, 0);
                println!("Got var: {:?}", var);
                println!("Stack Frame: {:?}", program_data.get_stack_frame_by_index(stack_frame));
                Some(Literal::Number(var.local_offset as i64))
            },
            BuiltInFunctionsAst::Format(format) => {
                let mut result = String::new();

                let mut position : usize = 0;

                for arg in format.args_provided.clone() {
                    loop {
                        match format.string.chars().nth(position).unwrap() {
                            '{' => {
                                position += 1;

                                if format.string.chars().nth(position).unwrap() != '}' {
                                    panic!("Expected '}}' after '{{' in format");
                                }

                                position += 1;

                                match arg {
                                    Expression::Literal(Literal::Number(num)) => {
                                        result.push_str(&num.to_string());
                                    },
                                    Expression::Literal(Literal::String(string)) => {
                                        result.push_str(&string);
                                    },
                                    Expression::BuiltInFunction(func) => {
                                        let parsed_func = func.parse(program_data, stack_frame);
                                        result.push_str(&parsed_func.unwrap().to_string());
                                    }
                                    _ => {
                                        panic!("Invalid Format");
                                    }
                                }

                                break;
                            },
                            _ => {
                                result.push(format.string.chars().nth(position).unwrap());

                                position += 1;
                            }
                        }
                    }
                }

                while position < format.string.len() {
                    result.push(format.string.chars().nth(position).unwrap());
                    position += 1;
                }

                return Some(Literal::String(result));

            }
            _ => unreachable!()
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Format {
    pub string : String,
    pub args_provided : Vec<Expression>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct VariableDeclaration {
    pub name: String,
    pub variable_type: VariableType,
    pub value: Option<Expression>,
}

#[derive(Debug, PartialEq, Clone)]
pub enum Expression {
    Literal(Literal),
    Identifier(Identifiers),
    BuiltInFunction(BuiltInFunctionsAst)
}

#[derive(Debug, PartialEq, Clone)]
pub enum Literal {
    String(String),
    Number(i64)
}

impl Literal {
    pub fn to_string(&self) -> String {
        let res : String = match self {
            Literal::String(str) => str.clone(),
            Literal::Number(num) => num.to_string()
        };

        return res;
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum VariableType {
    I8,
    I16,
    I32,
    I64,
    U8,
    U16,
    U32,
    U64,
    Void
}

impl VariableType {
    #[inline]
    pub fn get_variable_size(&self) -> usize {
        return match self {
            VariableType::I8 => 1,
            VariableType::I16 => 2,
            VariableType::I32 => 4,
            VariableType::I64 => 8,
            VariableType::U8 => 1,
            VariableType::U16 => 2,
            VariableType::U32 => 4,
            VariableType::U64 => 8,
            VariableType::Void => 0
        }
    }

}

// Code gen specific Structs
#[derive(Debug, PartialEq, Clone)]
pub struct CgStatement {
    pub statement_type : CgStatementType
}

#[derive(Debug, PartialEq, Clone)]
pub enum CgStatementType {
    VariableInitialization(CgVariableInitialization),
    BuiltInFunction(CgBuiltInFunctions)
}

#[derive(Debug, PartialEq, Clone)]
pub enum CgBuiltInFunctions {
    Assembly(String),
    BranchLinked(CgBranchLinked)
}

#[derive(Debug, PartialEq, Clone)]
pub struct CgBranchLinked {
    pub function_name : String,
    pub args : Vec<CgExpression>
}

#[derive(Debug, PartialEq, Clone)]
pub enum CgExpression {
    StackVariableIdentifier(String),
    FunctionArgIdentifier(String)
    Literal(Literal)
}

#[derive(Debug, PartialEq, Clone)]
pub struct CgVariableInitialization {
    pub init_value : CgExpression,
    pub var_name : String,
    pub stack_frame : usize
}
